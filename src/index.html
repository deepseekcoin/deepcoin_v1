<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepCoin Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .chart-container {
            background-color: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        h1, h2 {
            color: #4CAF50;
        }
        .token-name {
            font-size: 28px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 20px;
            text-align: center;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .stat-card {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        .stat-label {
            font-size: 14px;
            color: #888;
        }
        .levels {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            padding: 10px;
            background-color: #2d2d2d;
            border-radius: 8px;
        }
        .level {
            text-align: center;
        }
        .level-label {
            font-size: 14px;
            color: #888;
        }
        .level-value {
            font-size: 18px;
            color: #4CAF50;
        }
        .status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #2d2d2d;
            border-radius: 8px;
            font-size: 14px;
            color: #888;
        }
        .status.connected {
            color: #4CAF50;
        }
        .status.disconnected {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DeepCoin Analysis</h1>
        <div class="token-name" id="tokenName">-</div>
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="currentPrice">-</div>
                <div class="stat-label">Current Price</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="volume">-</div>
                <div class="stat-label">24h Volume</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="predictedPrice">-</div>
                <div class="stat-label">Predicted Price</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="confidence">-</div>
                <div class="stat-label">Confidence</div>
            </div>
        </div>

        <div class="chart-container">
            <h2>Price History</h2>
            <canvas id="priceChart"></canvas>
        </div>

        <div class="chart-container">
            <h2>Price Predictions</h2>
            <canvas id="predictionChart"></canvas>
            <div class="levels">
                <div class="level">
                    <div class="level-label">Support Levels</div>
                    <div class="level-value" id="supportLevels">-</div>
                </div>
                <div class="level">
                    <div class="level-label">Resistance Levels</div>
                    <div class="level-value" id="resistanceLevels">-</div>
                </div>
            </div>
        </div>
    </div>

    <div id="status" class="status">Connecting...</div>

    <script>
        // WebSocket connection
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        let ws = new WebSocket(`${protocol}//${window.location.host}`);
        let priceChart, predictionChart;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const reconnectDelay = 2000;

        function updateStatus(connected) {
            const status = document.getElementById('status');
            status.textContent = connected ? 'Connected' : 'Disconnected';
            status.className = `status ${connected ? 'connected' : 'disconnected'}`;
        }

        function setupWebSocket() {
            ws.onopen = () => {
                console.log('WebSocket connected');
                updateStatus(true);
                reconnectAttempts = 0;
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                switch (data.type) {
                    case 'price':
                        updatePriceData(data);
                        break;
                    case 'prediction':
                        updatePredictionData(data);
                        break;
                    case 'heartbeat':
                        ws.send(JSON.stringify({ type: 'ping' }));
                        break;
                    case 'error':
                        console.error('Server error:', data.message);
                        break;
                }
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                updateStatus(false);
                reconnect();
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus(false);
            };
        }

        function reconnect() {
            if (reconnectAttempts >= maxReconnectAttempts) {
                console.log('Max reconnection attempts reached');
                return;
            }

            reconnectAttempts++;
            console.log(`Reconnecting... Attempt ${reconnectAttempts}`);
            setTimeout(() => {
                ws = new WebSocket(`${protocol}//${window.location.host}`);
                setupWebSocket();
            }, reconnectDelay);
        }

        function updatePriceData(data) {
            if (data.tokenName) {
                document.getElementById('tokenName').textContent = data.tokenName;
            }
            if (data.currentPrice) {
                document.getElementById('currentPrice').textContent = 
                    data.currentPrice.toFixed(8);
            }
            if (data.volume) {
                document.getElementById('volume').textContent = 
                    data.volume.toFixed(2);
            }

            updatePriceChart(data.priceData);
        }

        function updatePredictionData(data) {
            if (data.predictedPrice) {
                document.getElementById('predictedPrice').textContent = 
                    data.predictedPrice.toFixed(8);
            }
            if (data.confidence) {
                document.getElementById('confidence').textContent = 
                    `${(data.confidence * 100).toFixed(1)}%`;
            }
            if (data.supportLevels) {
                document.getElementById('supportLevels').textContent = 
                    data.supportLevels.map(l => l.toFixed(8)).join(', ');
            }
            if (data.resistanceLevels) {
                document.getElementById('resistanceLevels').textContent = 
                    data.resistanceLevels.map(l => l.toFixed(8)).join(', ');
            }

            updatePredictionChart(data.predictions);
        }

        function updatePriceChart(priceData) {
            if (!priceData) return;

            if (!priceChart) {
                const ctx = document.getElementById('priceChart').getContext('2d');
                priceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Price',
                            data: [],
                            borderColor: '#4CAF50',
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        scales: {
                            y: {
                                grid: {
                                    color: '#333'
                                },
                                ticks: {
                                    color: '#fff'
                                }
                            },
                            x: {
                                grid: {
                                    color: '#333'
                                },
                                ticks: {
                                    color: '#fff'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#fff'
                                }
                            }
                        }
                    }
                });
            }

            priceChart.data.labels = priceData.map(d => 
                new Date(d.timestamp).toLocaleTimeString());
            priceChart.data.datasets[0].data = priceData.map(d => d.price);
            priceChart.update();
        }

        function updatePredictionChart(predictions) {
            if (!predictions) return;

            if (!predictionChart) {
                const ctx = document.getElementById('predictionChart').getContext('2d');
                predictionChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Actual',
                            data: [],
                            borderColor: '#4CAF50',
                            tension: 0.4
                        }, {
                            label: 'Predicted',
                            data: [],
                            borderColor: '#FFA726',
                            borderDash: [5, 5],
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        scales: {
                            y: {
                                grid: {
                                    color: '#333'
                                },
                                ticks: {
                                    color: '#fff'
                                }
                            },
                            x: {
                                grid: {
                                    color: '#333'
                                },
                                ticks: {
                                    color: '#fff'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#fff'
                                }
                            }
                        }
                    }
                });
            }

            const timestamps = [...predictions.actual.map(d => d.timestamp), 
                             ...predictions.predicted.map(d => d.timestamp)];
            predictionChart.data.labels = timestamps.map(t => 
                new Date(t).toLocaleTimeString());
            
            predictionChart.data.datasets[0].data = predictions.actual.map(d => ({
                x: new Date(d.timestamp).toLocaleTimeString(),
                y: d.price
            }));
            
            predictionChart.data.datasets[1].data = predictions.predicted.map(d => ({
                x: new Date(d.timestamp).toLocaleTimeString(),
                y: d.price
            }));
            
            predictionChart.update();
        }

        // Initialize WebSocket connection
        setupWebSocket();
    </script>
</body>
</html>
